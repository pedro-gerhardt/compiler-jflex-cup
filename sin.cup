import java_cup.runtime.*;

parser code {:
    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");

        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

            if (s.value != null) {
                m.append(": value: " + s.value.toString() + " - ");
            }

            if (s.left >= 0) {
                m.append("in line "+(s.left+1));
                if (s.right >= 0)
                    m.append(", column "+(s.right+1));
            }
        }

        m.append(" : " + message);

        System.err.println("\n" + m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};

terminal CLASS, INT, BOOL, VOID, TRUE, FALSE, AND, OR, NOT, IF, ELSE, FOR, WHILE, RETURN; 
terminal EQ, EQEQ, NOTEQ, GT, LT, PLUS, MINUS, TIMES, DIVIDE; 
terminal COMMA, SEMI, LPAREN, RPAREN, LCURLY, RCURLY;
terminal IDENT, NUM;
terminal EMPTY;

non terminal program;
non terminal type, attr;
non terminal logic_oper, rel_oper, const_bool, exp_bool, term_bool, factor_bool;
non terminal method_call_arit, args_arit, exp_arit, term_arit, factor_arit;

start with program;

program ::= exp_arit;

type ::= INT | BOOL;

attr ::= type IDENT SEMI;

// boolean expression
logic_oper ::= AND | OR;
rel_oper ::= EQEQ | GT | LT | NOTEQ;
const_bool ::= TRUE | FALSE;

exp_bool ::= term_bool | term_bool logic_oper exp_bool;
term_bool ::= factor_bool | factor_bool rel_oper term_bool;
factor_bool ::= NOT factor_bool | const_bool | IDENT | LPAREN exp_bool RPAREN;

// arithmetic expression
exp_arit ::= term_arit | term_arit PLUS exp_arit;
term_arit ::= factor_arit | factor_arit TIMES term_arit;
factor_arit ::= NUM | IDENT | method_call_arit | LPAREN exp_arit RPAREN;

method_call_arit ::= IDENT LPAREN RPAREN | IDENT LPAREN args_arit RPAREN;
args_arit ::= exp_arit | exp_arit COMMA args_arit | EMPTY;

